<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vault</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23007acc' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><rect x='3' y='11' width='18' height='11' rx='2' ry='2'></rect><path d='M7 11V7a5 5 0 0 1 10 0v4'></path></svg>">
    <!--
    Vault: single-file, offline, quineâ€‘ish minimal encrypted notepad.
    - AES-GCM 256 + PBKDF2(SHA-256, 200k), salt+iv per save.
    - FS Access API when available, else download; file handle stored in IndexedDB.
    -->
    <style>
        :root {
            --bg-color: #1e1e1e; --ui-bg-color: #252526; --input-bg: #3c3c3c; --border-color: #3c3c3c;
            --text-color: #cccccc; --text-color-muted: #8c8c8c; --accent-color: #007acc; --accent-hover-color: #0098e6;
            --danger-color: #f44747; --success-color: #34c759;
        }
        html { box-sizing: border-box; }
        *, *:before, *:after { box-sizing: inherit; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color); color: var(--text-color); margin: 0; overflow: hidden;
        }
        h2 { color: var(--text-color); border-bottom: none; padding-bottom: 0; margin: 0 0 1.5em 0; font-size: 1.5em; font-weight: 300; text-align: center; }
        h3 { margin: 0 0 1em 0; font-weight: 400; }

        .container { width: 100vw; height: 100dvh; display: flex; flex-direction: column; position: relative; }
        #main-view { width: 100%; height: 100%; display: flex; flex-direction: column; gap: 1em; padding: 1.5em; }
        #main-view-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1em; flex-shrink: 0; }
        #main-view-header h2 { margin: 0; font-size: 1em; font-weight: 400; color: var(--text-color-muted); text-align: left; }
        .header-actions { display: flex; align-items: center; gap: 0.8em; }

        dialog { background: transparent; border: none; padding: 0; max-width: 450px; width: 90%; margin: auto; }
        dialog::backdrop { background-color: rgba(0, 0, 0, 0.6); }
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            background-color: rgba(0, 0, 0, 0.6); z-index: 1000;
        }
        .modal-overlay .form-container,
        dialog .form-container {
            background-color: var(--ui-bg-color); padding: 2.5em; border-radius: 8px;
            position: relative; max-width: 450px; width: 90%;
        }
        .form-container p { color: var(--text-color-muted); text-align: center; margin: 0 0 1.5em; line-height: 1.4; }
        
        input[type="password"], textarea {
            background-color: var(--input-bg); border: 1px solid var(--border-color); color: var(--text-color); border-radius: 4px;
            padding: 12px; font-size: 1em; width: 100%; margin-bottom: 1em; transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        input[type="password"]:focus, textarea:focus {
            outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 1px var(--accent-color);
        }
        #notepad {
            flex-grow: 1; min-height: 0; border: none; background-color: var(--bg-color);
            font-family: 'SF Mono', 'Consolas', 'Menlo', monospace; font-size: 1.1em;
            resize: none; margin: 0; padding: 1em;
        }
        #notepad:focus { box-shadow: none; }

        button {
            padding: 12px 20px; border: 1px solid transparent; border-radius: 4px; cursor: pointer;
            font-size: 1em; font-weight: 600; transition: background-color 0.2s ease, color 0.2s ease;
        }
        button:disabled { opacity: 0.5; cursor: not-allowed; pointer-events: none; }
        button[type="submit"] { width: 100%; background-color: var(--accent-color); color: white; }
        button[type="submit"]:hover { background-color: var(--accent-hover-color); }
        button.secondary { background-color: transparent; color: var(--text-color-muted); font-weight: 400; padding: 8px 16px; width: 100%; margin-top: 1em; }
        button.secondary:hover { color: var(--text-color); background-color: var(--input-bg); }
        .icon-button {
            background: none; border: none; padding: 5px; cursor: pointer; color: var(--text-color-muted);
            transition: color 0.2s ease, opacity 0.2s ease; line-height: 0; position: relative;
        }
        .icon-button svg { width: 22px; height: 22px; stroke: currentColor; stroke-width: 1.5; fill: none; }
        .icon-button:hover:not(:disabled) { color: var(--accent-color); }
        .icon-button.is-linked { color: var(--success-color); }
        .icon-button.is-linked:hover { color: #4cd964; }
        @media (hover: none) and (pointer: coarse) {
            .icon-button:hover:not(:disabled) { color: var(--text-color-muted); }
        }

        .hidden { display: none !important; }
        .error { color: var(--danger-color); margin-top: 1em; text-align: center; }
        #unsaved-indicator { color: var(--accent-color); font-weight: bold; margin-left: 0.25em; }

        .icon-button.is-success { color: var(--success-color) !important; }
        .icon-button.is-error { color: var(--danger-color) !important; }
        
        @keyframes draw-circle { to { stroke-dashoffset: 0; } }
        @keyframes draw-symbol { to { stroke-dashoffset: 0; } }
        @keyframes fade-in-symbol { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }
        
        .icon-button svg .icon-success, .icon-button svg .icon-error { display: none; }
        .icon-button.is-success .icon-default, .icon-button.is-error .icon-default { display: none; }
        .icon-button.is-success .icon-success, .icon-button.is-error .icon-error { display: block; }

        .icon-button.is-success svg .feedback-circle,
        .icon-button.is-error svg .feedback-circle {
          stroke-dasharray: 63; stroke-dashoffset: 63;
          transform-origin: center; transform: rotate(-90deg);
          animation: draw-circle 0.6s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }
        .icon-button.is-success svg .feedback-symbol {
          stroke-dasharray: 14; stroke-dashoffset: 14;
          animation: draw-symbol 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards 0.3s;
        }
        .icon-button.is-error svg .feedback-symbol {
            opacity: 0; transform-origin: center;
            animation: fade-in-symbol 0.3s ease-out forwards 0.4s;
        }
        .icon-button svg .feedback-circle { stroke-width: 1.5; fill: none; }
        .icon-button svg .feedback-symbol { stroke-width: 2; fill: none; stroke-linecap: round; }

        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: var(--bg-color); }
        ::-webkit-scrollbar-thumb { background-color: var(--input-bg); border-radius: 5px; border: 2px solid var(--bg-color); }
        ::-webkit-scrollbar-thumb:hover { background-color: var(--text-color-muted); }
        ::-webkit-scrollbar-corner { background: var(--bg-color); }
    </style>
</head>
<body>
    <div class="container">
        <dialog id="password-modal">
            <form method="dialog" class="form-container" id="password-form">
                <h2>Set Password</h2>
                <input type="password" id="password-input" placeholder="Enter password" autocomplete="new-password">
                <input type="password" id="password-confirm" placeholder="Confirm password" autocomplete="new-password">
                <button type="submit" value="confirm">Confirm</button>
                <button type="submit" value="cancel" class="secondary">Cancel</button>
                <p id="password-error" class="error"></p>
            </form>
        </dialog>

        <div id="login-view" class="modal-overlay hidden">
            <div class="form-container">
                <form id="login-form">
                    <h2>Unlock Vault</h2>
                    <p>Enter your master password to decrypt this file.</p>
                    <input type="password" id="master-password" placeholder="Master Password" required autofocus>
                    <button type="submit">Unlock</button>
                    <p id="error-message" class="error"></p>
                </form>
            </div>
        </div>
        
        <div id="main-view" class="hidden">
            <div id="main-view-header">
                <h2>VAULT<span id="unsaved-indicator" class="hidden">*</span></h2>
                <div class="header-actions">
                    <button id="link-btn" class="icon-button hidden" title="Link to file for direct saving">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
                            <g class="icon-default">
                                <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path>
                                <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path>
                            </g>
                            <g class="icon-success">
                                <circle class="feedback-circle" cx="12" cy="12" r="10" />
                                <path class="feedback-symbol" d="M8 12.5l3 3 5-5" />
                            </g>
                            <g class="icon-error">
                                <circle class="feedback-circle" cx="12" cy="12" r="10" />
                                <path class="feedback-symbol" d="M15 9l-6 6M9 9l6 6" />
                            </g>
                        </svg>
                    </button>
                    <button id="save-btn" class="icon-button" title="Download updated file (Ctrl+S)">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
                            <g class="icon-default">
                                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                                <polyline points="17 21 17 13 7 13 7 21"></polyline>
                                <polyline points="7 3 7 8 15 8"></polyline>
                            </g>
                            <g class="icon-success">
                                <circle class="feedback-circle" cx="12" cy="12" r="10" />
                                <path class="feedback-symbol" d="M8 12.5l3 3 5-5" />
                            </g>
                            <g class="icon-error">
                                <circle class="feedback-circle" cx="12" cy="12" r="10" />
                                <path class="feedback-symbol" d="M15 9l-6 6M9 9l6 6" />
                            </g>
                        </svg>
                    </button>
                    <button id="password-btn" class="icon-button" title="Change master password">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path></svg>
                    </button>
                    <button id="lock-btn" class="icon-button" title="Lock vault (Ctrl+R / F5)">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="10" width="18" height="11" rx="2" ry="2"></rect><path d="M7 10V6a5 5 0 0 1 10 0v4"></path></svg>
                    </button>
                </div>
            </div>
            
            <textarea
                id="notepad"
                placeholder="Your protected text..."
                spellcheck="false"
                autocorrect="off"
                autocapitalize="off"
                autocomplete="off"
                autofocus
            ></textarea>
        </div>
    </div>

<script id="vault-data" type="text/encrypted-json"></script>

<script>
// =============================================================================
// State
// =============================================================================
const state = {
    vaultId: null,
    content: '',
    originalContent: '',
    password: null,
    fileHandle: null,
    isDirty: false
};

// =============================================================================
// DOM Cache
// =============================================================================
const $ = id => document.getElementById(id);
const PRISTINE_HTML = document.documentElement.outerHTML;

let $loginView, $loginForm, $masterPassword, $errorMsg;
let $mainView, $notepad, $unsavedIndicator;
let $saveBtn, $linkBtn, $passwordBtn, $lockBtn;
let $passwordModal, $passwordForm, $passwordInput, $passwordConfirm, $passwordError;

// =============================================================================
// Crypto Service
// =============================================================================
const Crypto = (() => {
    const ITERATIONS = 200_000;
    const toBase64 = buf => btoa(String.fromCharCode(...new Uint8Array(buf)));
    const fromBase64 = b64 => Uint8Array.from(atob(b64), c => c.charCodeAt(0)).buffer;
    
    const deriveKey = async (password, salt) => {
        const baseKey = await crypto.subtle.importKey(
            'raw', new TextEncoder().encode(password), 'PBKDF2', false, ['deriveKey']
        );
        return crypto.subtle.deriveKey(
            { name: 'PBKDF2', salt, iterations: ITERATIONS, hash: 'SHA-256' },
            baseKey, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']
        );
    };

    return {
        async encrypt(plaintext, password) {
            const salt = crypto.getRandomValues(new Uint8Array(16));
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const key = await deriveKey(password, salt);
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv }, key, new TextEncoder().encode(plaintext)
            );
            return JSON.stringify({ salt: toBase64(salt), iv: toBase64(iv), data: toBase64(encrypted) });
        },
        
        async decrypt(encryptedText, password) {
            try {
                const { salt, iv, data } = JSON.parse(encryptedText);
                const key = await deriveKey(password, fromBase64(salt));
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: fromBase64(iv) }, key, fromBase64(data)
                );
                return JSON.parse(new TextDecoder().decode(decrypted));
            } catch {
                throw new Error('Decryption failed');
            }
        }
    };
})();

// =============================================================================
// Storage Service (IndexedDB for file handles)
// =============================================================================
const Storage = (() => {
    let db = null;
    
    const openDB = async () => {
        if (db) return db;
        return new Promise((resolve, reject) => {
            const req = indexedDB.open('vault-db', 1);
            req.onupgradeneeded = () => {
                if (!req.result.objectStoreNames.contains('handles')) {
                    req.result.createObjectStore('handles', { keyPath: 'id' });
                }
            };
            req.onsuccess = () => { db = req.result; resolve(db); };
            req.onerror = () => reject(req.error);
        });
    };

    return {
        async saveHandle(id, handle) {
            const database = await openDB();
            const tx = database.transaction('handles', 'readwrite');
            tx.objectStore('handles').put({ id, handle });
            return new Promise((res, rej) => { tx.oncomplete = res; tx.onerror = () => rej(tx.error); });
        },
        
        async getHandle(id) {
            if (!id) return null;
            const database = await openDB();
            const tx = database.transaction('handles', 'readonly');
            const req = tx.objectStore('handles').get(id);
            return new Promise((res, rej) => { tx.oncomplete = () => res(req.result?.handle); tx.onerror = () => rej(tx.error); });
        }
    };
})();

// =============================================================================
// File Service
// =============================================================================
const File = (() => {
    const getPristineDoc = () => new DOMParser().parseFromString('<!DOCTYPE html>\n' + PRISTINE_HTML, 'text/html');
    
    return {
        async generateHTML(payload, password) {
            const encrypted = await Crypto.encrypt(JSON.stringify(payload), password);
            const doc = getPristineDoc();
            doc.getElementById('vault-data').textContent = encrypted;
            return '<!DOCTYPE html>\n' + doc.documentElement.outerHTML;
        },
        
        async download(content, filename) {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            
            if (isIOS && navigator.share && navigator.canShare) {
                try {
                    const file = new File([content], filename, { type: 'text/html' });
                    if (navigator.canShare({ files: [file] })) {
                        await navigator.share({ files: [file] });
                        return { success: true };
                    }
                } catch (err) {
                    if (err.name === 'AbortError') return { cancelled: true };
                }
            }

            if ('showSaveFilePicker' in window) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: filename,
                        types: [{ description: 'HTML Vault', accept: { 'text/html': ['.html'] } }],
                    });
                    await this.writeToHandle(handle, content);
                    return { success: true };
                } catch (err) {
                    if (err.name === 'AbortError') return { cancelled: true };
                    return { success: false, error: err };
                }
            }

            const blob = new Blob([content], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = Object.assign(document.createElement('a'), { href: url, download: filename });
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 100);
            return { success: true };
        },
        
        async writeToHandle(handle, content) {
            const writable = await handle.createWritable();
            await writable.write(content);
            await writable.close();
        },
        
        async pickFile() {
            const [handle] = await window.showOpenFilePicker({
                types: [{ description: 'HTML Vault', accept: { 'text/html': ['.html'] } }]
            });
            return handle;
        },
        
        async checkPermission(handle) {
            if (!handle) return false;
            if (await handle.queryPermission({ mode: 'readwrite' }) === 'granted') return true;
            const perm = await handle.requestPermission({ mode: 'readwrite' });
            if (perm === 'prompt') throw new Error('Permission prompt pending');
            return perm === 'granted';
        }
    };
})();

// =============================================================================
// UI Helpers
// =============================================================================
const animTimers = new WeakMap();

function animateFeedback(button, success) {
    const cls = success ? 'is-success' : 'is-error';
    const other = success ? 'is-error' : 'is-success';
    const duration = success ? 2000 : 3500;

    const prev = animTimers.get(button);
    if (prev) { clearTimeout(prev.timer); button.classList.remove(prev.cls); }

    button.classList.remove(other);
    button.classList.add(cls);

    const timer = setTimeout(() => { button.classList.remove(cls); animTimers.delete(button); }, duration);
    animTimers.set(button, { timer, cls });
}

function updateDirtyIndicator() {
    $unsavedIndicator.classList.toggle('hidden', !state.isDirty);
}

function promptPassword() {
    return new Promise(resolve => {
        const handleClose = () => {
            $passwordModal.removeEventListener('close', handleClose);
            if ($passwordModal.returnValue === 'confirm') {
                resolve($passwordInput.value);
            } else {
                resolve(null);
            }
            $passwordError.textContent = '';
            $passwordForm.reset();
        };
        $passwordModal.addEventListener('close', handleClose);
        $passwordModal.showModal();
    });
}

// =============================================================================
// Actions
// =============================================================================
async function unlock(password) {
    try {
        $errorMsg.textContent = '';
        const encrypted = $('vault-data').textContent.trim();
        const { content, vaultId } = await Crypto.decrypt(encrypted, password);
        
        state.content = content;
        state.originalContent = content;
        state.password = password;
        state.vaultId = vaultId;
        state.isDirty = false;
        state.fileHandle = null;

        if (vaultId && 'showOpenFilePicker' in window) {
            try { state.fileHandle = await Storage.getHandle(vaultId); } catch {}
        }
        
        if (state.fileHandle) $linkBtn.classList.add('is-linked');
        
        $loginView.classList.add('hidden');
        $mainView.classList.remove('hidden');
        $notepad.value = content;
        $notepad.focus({ preventScroll: true });
        $notepad.setSelectionRange(0, 0);
    } catch {
        $errorMsg.textContent = 'Invalid password';
        $masterPassword.select();
    }
}

async function save() {
    if (!state.password) {
        state.password = await promptPassword();
        if (!state.password) return;
    }
    
    try {
        const vaultId = state.vaultId || crypto.randomUUID();
        const payload = { content: state.content, vaultId };
        const html = await File.generateHTML(payload, state.password);

        let success = false;
        if (state.fileHandle && await File.checkPermission(state.fileHandle)) {
            await File.writeToHandle(state.fileHandle, html);
            success = true;
        } else {
            const result = await File.download(html, `vault-${vaultId.substring(0, 8)}.html`);
            if (result.cancelled) return;
            success = result.success;
        }

        if (success) {
            state.originalContent = state.content;
            state.isDirty = false;
            state.vaultId = vaultId;
            updateDirtyIndicator();
            animateFeedback($saveBtn, true);
        } else {
            animateFeedback($saveBtn, false);
        }
    } catch (err) {
        console.error('Save failed:', err);
        animateFeedback($saveBtn, false);
    }
}

async function link() {
    if (!state.password) {
        state.password = await promptPassword();
        if (!state.password) return;
    }

    try {
        const handle = await File.pickFile();
        const vaultId = state.vaultId || crypto.randomUUID();
        const payload = { content: state.content, vaultId };
        const html = await File.generateHTML(payload, state.password);
        
        await File.writeToHandle(handle, html);
        await Storage.saveHandle(vaultId, handle);
        
        state.fileHandle = handle;
        state.vaultId = vaultId;
        state.originalContent = state.content;
        state.isDirty = false;
        
        updateDirtyIndicator();
        animateFeedback($linkBtn, true);
        $linkBtn.classList.add('is-linked');
    } catch (err) {
        if (err.name !== 'AbortError') {
            console.error('Link failed:', err);
            animateFeedback($linkBtn, false);
            $linkBtn.classList.remove('is-linked');
        }
    }
}

async function changePassword() {
    const newPassword = await promptPassword();
    if (newPassword) {
        state.password = newPassword;
        save();
    }
}

function onContentChange(content) {
    state.content = content;
    state.isDirty = content !== state.originalContent;
    updateDirtyIndicator();
}

// =============================================================================
// Initialize
// =============================================================================
function init() {
    // Cache DOM elements
    $loginView = $('login-view');
    $loginForm = $('login-form');
    $masterPassword = $('master-password');
    $errorMsg = $('error-message');
    $mainView = $('main-view');
    $notepad = $('notepad');
    $unsavedIndicator = $('unsaved-indicator');
    $saveBtn = $('save-btn');
    $linkBtn = $('link-btn');
    $passwordBtn = $('password-btn');
    $lockBtn = $('lock-btn');
    $passwordModal = $('password-modal');
    $passwordForm = $('password-form');
    $passwordInput = $('password-input');
    $passwordConfirm = $('password-confirm');
    $passwordError = $('password-error');

    // Bind events
    $loginForm.addEventListener('submit', e => { e.preventDefault(); unlock($masterPassword.value); });
    $saveBtn.addEventListener('click', save);
    $linkBtn.addEventListener('click', link);
    $passwordBtn.addEventListener('click', changePassword);
    $lockBtn.addEventListener('click', () => location.reload());
    $notepad.addEventListener('input', e => onContentChange(e.target.value));
    
    $passwordForm.addEventListener('submit', e => {
        if (e.submitter?.value === 'cancel') return;
        e.preventDefault();
        if (!$passwordInput.value) {
            $passwordError.textContent = 'Password cannot be empty.';
        } else if ($passwordInput.value !== $passwordConfirm.value) {
            $passwordError.textContent = 'Passwords do not match.';
        } else {
            $passwordModal.close('confirm');
        }
    });

    document.addEventListener('keydown', e => {
        if ((e.ctrlKey || e.metaKey) && e.code === 'KeyS') { e.preventDefault(); save(); }
    });

    // Show File System Access API button if supported
    if ('showOpenFilePicker' in window) $linkBtn.classList.remove('hidden');

    // Initial state based on encrypted data presence
    const encrypted = $('vault-data').textContent.trim();
    if (!encrypted) {
        $mainView.classList.remove('hidden');
        $notepad.focus();
    } else {
        $loginView.classList.remove('hidden');
        $masterPassword.focus();
    }
}

init();
</script>
</body>
</html>